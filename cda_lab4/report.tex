\documentclass[12pt, letterpaper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage[font={small,it}, justification=centering, labelfont=bf]{caption}
\usepackage{float}
\usepackage[skip=4pt]{parskip}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{enumitem}
\usepackage{pdfpages}

\titlespacing*{\section}{0pt}{8pt}{4pt}
\titlespacing*{\subsection}{0pt}{6pt}{2pt}

% Roman numeral section counter
\renewcommand{\thesection}{\Roman{section}}
\titleformat{\section}{\normalfont\bfseries\large}{\thesection.}{0.5em}{}

% Simple arabic numbering for subsections
\renewcommand{\thesubsection}{\arabic{subsection}}
\titleformat{\subsection}{\normalfont\bfseries}{\thesubsection.}{0.5em}{}

% Bullet style: use filled circle, no dash
\setlist[itemize]{label=$\bullet$}

% Verilog listing style
\lstdefinelanguage{Verilog}{
  morekeywords={module, endmodule, input, output, wire, reg, initial, begin,
                end, assign, always, posedge, negedge, if, else},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}
\lstset{
  language=Verilog,
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries,
  commentstyle=\color{gray}\itshape,
  frame=single,
  breaklines=true,
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny\color{gray},
  xleftmargin=2em,
}

\begin{document}

\begin{center}
  {\large \textbf{Report for CDA 3201L Lab \#4}}\\[2pt]
  {\large \textbf{Combinational Logic Design and Verilog HDL}}\\[8pt]
  \begin{tabular}{ll}
    \textbf{Name:} Tuan Khang Phan & \textbf{UID:} 030382645 \\
    \textbf{Name:} Huu Phat Nguyen & \textbf{UID:} U46082380 \\
  \end{tabular}
\end{center}

\section{Introduction}

In this experiment, a full adder circuit was designed and tested using both physical
hardware and Verilog HDL. The full adder adds three 1-bit inputs ($a$, $b$, $c_{in}$)
and produces two outputs ($sum$ and $c_{out}$). First, the truth table and Boolean
expressions were derived using Karnaugh maps, then optimized using XOR identities.
The optimized circuit was built on a breadboard using XOR and NAND gates, and the
same design was implemented in structural Verilog and simulated on EDAPlayground to
verify that both implementations produce identical results.

\section{Methods and Materials}

\subsection{Materials}

\begin{itemize}
  \item \textbf{Breadboard:} A prototyping board used to construct circuits without
        soldering. Components and wires are inserted into the holes, which are
        internally connected in rows, allowing quick assembly and testing.

  \item \textbf{Integrated Circuits (ICs):} The SN74LS86N IC (Quad 2-input XOR gate)
        was used to implement the XOR gates required for the $sum$ output. The
        SN74LS00N IC (Quad 2-input NAND gate) was used to implement the NAND gates
        required for the carry output. The datasheets for both ICs were consulted to
        determine pin configurations and power supply connections.

  \item \textbf{Wiring:} A wire jumper kit with wires of different lengths was used to
        connect components on the breadboard. Alligator clips were used to connect the
        power supply to the breadboard rails.

  \item \textbf{LEDs and Resistors:} LEDs were used to indicate the logic state of the
        circuit outputs. When the output is logic 1, the LED emits light; when the
        output is logic 0, the LED remains off. A 470\,$\Omega$ resistor was connected
        in series with each LED to limit current and prevent damage.

  \item \textbf{Power Supply:} A 5\,V DC power supply was used to power the ICs and
        provide logic HIGH and LOW levels for the inputs.

  \item \textbf{EDA Playground:} An online Verilog simulation tool used to write, run,
        and test Verilog code. The Synopsys VCS simulator was selected, and the EPWave
        waveform viewer was used to display timing diagrams.
\end{itemize}

\subsection{Methods}

\begin{enumerate}
  \item The truth table for the full adder was created using the three inputs
        ($a$, $b$, $c_{in}$) and two outputs ($sum$, $c_{out}$).
  \item K-maps were used to simplify the Boolean expressions for $sum$ and $c_{out}$.
  \item The $sum$ output was implemented using XOR gates, and the $c_{out}$ output was
        implemented using NAND gates.
  \item The circuit was optimized to reuse the intermediate $a \oplus b$ signal, reducing
        the total gate count to 2 XOR gates and 3 NAND gates.
  \item The circuit was constructed on the breadboard using the 74LS86 and 74LS00 ICs,
        with LEDs connected to the outputs to verify functionality.
  \item The same optimized circuit was implemented in Verilog using structural modeling
        on EDA Playground.
  \item A testbench was written to exercise all eight input combinations and simulate
        the circuit.
  \item The console output and waveform were observed to confirm that the Verilog
        simulation matched the hardware results.
\end{enumerate}

\section{Lab Assignment Questions}

The handwritten solutions for Questions 1, 2, and 3 are included below.

\includepdf[pages={5,6,7}]{My_Answer.pdf}

\section{Experimental Results}

\subsection{Verilog Module}

The structural Verilog module below implements the optimized full adder using the
gate-level primitives \texttt{xor} and \texttt{nand}:

\begin{lstlisting}[caption={Verilog module for the optimized full adder.},
                   label={lst:module}]
module full_adder(a, b, cin, sum, cout);
    input  a, b, cin;
    output sum, cout;
    wire   x, n1, n2;

    xor  (x,    a,  b  );   // x    = a XOR b
    xor  (sum,  x,  cin);   // sum  = (a XOR b) XOR cin
    nand (n1,   a,  b  );   // n1   = NAND(a, b)
    nand (n2,   x,  cin);   // n2   = NAND(a XOR b, cin)
    nand (cout, n1, n2 );   // cout = NAND(n1, n2)
endmodule
\end{lstlisting}

\subsection{Verilog Testbench}

The testbench exercises all eight input combinations in sequential 10-time-unit steps,
cycling through the full truth table in binary order:

\begin{lstlisting}[caption={Testbench for the full adder module.},
                   label={lst:tb}]
module full_adder_tb();
    reg  a, b, cin;
    wire sum, cout;

    full_adder U0(a, b, cin, sum, cout);

    initial begin
        $dumpfile("test.vcd");
        $dumpvars;
        $display("Starting simulation...\n");
        $display("Time\ta\tb\tcin\tcout\tsum\n");
        $monitor("%2d\t%d\t%d\t%d\t%d\t%d",
                 $time, a, b, cin, cout, sum);

        a = 0; b = 0; cin = 0;   //  0: a=0 b=0 cin=0
        #10 cin = 1;              // 10: a=0 b=0 cin=1
        #10 cin = 0; b = 1;       // 20: a=0 b=1 cin=0
        #10 cin = 1;              // 30: a=0 b=1 cin=1
        #10 cin = 0; b = 0; a = 1;// 40: a=1 b=0 cin=0
        #10 cin = 1;              // 50: a=1 b=0 cin=1
        #10 cin = 0; b = 1;       // 60: a=1 b=1 cin=0
        #10 cin = 1;              // 70: a=1 b=1 cin=1
        #10 $finish;
    end
endmodule
\end{lstlisting}

\subsection{Simulation Console Output}

\begin{lstlisting}[language={}, numbers=none, frame=single,
                   caption={Simulation console output from Synopsys VCS.}]
Starting simulation...

Time    a    b    cin    cout    sum

 0      0    0     0      0       0
10      0    0     1      0       1
20      0    1     0      0       1
30      0    1     1      1       0
40      1    0     0      0       1
50      1    0     1      1       0
60      1    1     0      1       0
70      1    1     1      1       1
$finish at simulation time 80
\end{lstlisting}

All eight input combinations produce outputs that exactly match the truth table in
Table~\ref{tab:truth}, confirming correct functionality.

\subsection{Simulation Waveform}

% Uncomment below once waveform.png is placed in the cda_lab4 folder:
% \begin{figure}[H]
%   \centering
%   \includegraphics[width=0.95\linewidth]{waveform.png}
%   \caption{EPWave waveform from EDAPlayground showing signals $a$, $b$, $c_{in}$,
%            $c_{out}$, and $sum$ for all eight input combinations (0 to 70\,ns).}
%   \label{fig:wave}
% \end{figure}

\subsection{Physical Circuit}

% Uncomment below once circuit.jpg is placed in the cda_lab4 folder:
% \begin{figure}[H]
%   \centering
%   \includegraphics[width=0.70\linewidth]{circuit.jpg}
%   \caption{Breadboard implementation of the optimized full adder using SN74LS86N
%            (XOR) and SN74LS00N (NAND) ICs. LEDs at the $sum$ and $c_{out}$ outputs
%            confirm correct logic levels.}
%   \label{fig:circuit}
% \end{figure}

\section{Discussion}

The experimental results matched the expected truth table of the full adder. The
$sum$ output correctly represented the XOR of the three inputs, and the carry out
($c_{out}$) output correctly indicated a carry when at least two inputs were 1. The
breadboard implementation functioned properly, and the LEDs displayed the correct
output combinations for all input cases. Additionally, the Verilog simulation produced
the expected console output and waveform results. These findings confirm that both the
hardware implementation and the Verilog design were correct and functionally equivalent.

The key insight of Question~3 is that $c_{out} = 1$ precisely when at least two of the
three inputs are 1 (a majority function). Expressing this as
$c_{out} = ab + c_{in}(a \oplus b)$ allows the intermediate wire $x = a \oplus b$,
which is already required for computing $sum$, to be shared. This reduces the
$c_{out}$ path to only 3 NAND gates instead of the 4 required by the direct NAND-NAND
form of the MSOP. The sharing works because $c_{in}$ produces a carry when exactly one
of $a$ and $b$ is 1, and that condition is exactly $a \oplus b = 1$.

A minor difficulty was encountered during the wiring process on the breadboard.
Without a clear visualization of the optimized circuit, arranging the connections
between the two ICs required careful attention to the pin configurations from the
datasheets.

\section{Conclusion}

In this lab, a full adder circuit was successfully designed, implemented, and verified
using both hardware and Verilog HDL. The truth table and Boolean expressions were
derived using Karnaugh maps, and the circuit was implemented using XOR and NAND gates.
The design was optimized to reuse the $a \oplus b$ intermediate signal, reducing the
total gate count to 2 XOR gates (74LS86) and 3 NAND gates (74LS00). The breadboard
implementation and Verilog simulation both produced correct outputs for all input
combinations. This lab reinforced the understanding of combinational logic circuits,
Boolean algebra, and Verilog structural modeling.

\end{document}
